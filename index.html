<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Solar System of Emotions</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3CradialGradient id='sunGrad' cx='50%25' cy='50%25' r='50%25'%3E%3Cstop offset='0%25' style='stop-color:%23fff4e6;stop-opacity:1' /%3E%3Cstop offset='50%25' style='stop-color:%23ffcc00;stop-opacity:1' /%3E%3Cstop offset='100%25' style='stop-color:%23ff8c00;stop-opacity:1' /%3E%3C/radialGradient%3E%3C/defs%3E%3Crect width='100' height='100' fill='%23000000'/%3E%3Ccircle cx='50' cy='50' r='15' fill='url(%23sunGrad)'/%3E%3Ccircle cx='50' cy='50' r='17' fill='none' stroke='%23ffaa00' stroke-width='0.5' opacity='0.3'/%3E%3Ccircle cx='35' cy='35' r='4' fill='%2364b5f6'/%3E%3Ccircle cx='35' cy='35' r='5' fill='none' stroke='%2364b5f6' stroke-width='0.3' opacity='0.4'/%3E%3Ccircle cx='70' cy='40' r='3.5' fill='%23f48fb1'/%3E%3Ccircle cx='70' cy='40' r='4.5' fill='none' stroke='%23f48fb1' stroke-width='0.3' opacity='0.4'/%3E%3Ccircle cx='65' cy='65' r='3' fill='%23ffeb3b'/%3E%3Ccircle cx='65' cy='65' r='4' fill='none' stroke='%23ffeb3b' stroke-width='0.3' opacity='0.4'/%3E%3Ccircle cx='30' cy='60' r='3.5' fill='%2366bb6a'/%3E%3Ccircle cx='30' cy='60' r='4.5' fill='none' stroke='%2366bb6a' stroke-width='0.3' opacity='0.4'/%3E%3Ccircle cx='15' cy='50' r='1.5' fill='%23ffffff' opacity='0.6'/%3E%3Ccircle cx='85' cy='50' r='1.5' fill='%23ffffff' opacity='0.6'/%3E%3Ccircle cx='50' cy='15' r='1.5' fill='%23ffffff' opacity='0.6'/%3E%3Ccircle cx='50' cy='85' r='1.5' fill='%23ffffff' opacity='0.6'/%3E%3Ccircle cx='25' cy='25' r='1' fill='%23ffffff' opacity='0.4'/%3E%3Ccircle cx='75' cy='75' r='1' fill='%23ffffff' opacity='0.4'/%3E%3Ccircle cx='75' cy='25' r='1' fill='%23ffffff' opacity='0.4'/%3E%3Ccircle cx='25' cy='75' r='1' fill='%23ffffff' opacity='0.4'/%3E%3C/svg%3E">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Libre+Baskerville:wght@400;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Crimson Text', serif;
      background: #000000;
      color: #ffffff;
      overflow: hidden;
      cursor: none;
    }

    /* Custom Cursor */
    #cursor {
      position: fixed;
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      pointer-events: none;
      z-index: 10000;
      transition: transform 0.15s ease, border-color 0.3s ease;
      mix-blend-mode: difference;
    }

    #cursor.hovering {
      transform: scale(2);
      border-color: rgba(255, 200, 100, 0.8);
    }

    /* Pages */
    .page {
      position: fixed;
      inset: 0;
      display: none;
      opacity: 0;
      transition: opacity 1.5s cubic-bezier(0.22, 1, 0.36, 1);
    }

    .page.active {
      display: flex;
      opacity: 1;
    }

    /* LANDING PAGE */
    #landing {
      background: radial-gradient(ellipse at center, #0a0520 0%, #000000 100%);
      position: relative;
      overflow: hidden;
    }

    .stars-bg {
      position: absolute;
      inset: 0;
      background-image: 
        radial-gradient(2px 2px at 20% 30%, white, transparent),
        radial-gradient(2px 2px at 60% 70%, white, transparent),
        radial-gradient(1px 1px at 50% 50%, white, transparent),
        radial-gradient(1px 1px at 80% 10%, white, transparent),
        radial-gradient(2px 2px at 90% 60%, white, transparent),
        radial-gradient(1px 1px at 33% 80%, white, transparent);
      background-size: 200% 200%;
      animation: starsFloat 60s linear infinite;
      opacity: 0.6;
    }

    @keyframes starsFloat {
      0% { background-position: 0% 0%; }
      100% { background-position: 100% 100%; }
    }

    .landing-inner {
      margin: auto;
      text-align: center;
      padding: 40px;
      max-width: 720px;
      position: relative;
      z-index: 2;
      animation: landingFadeIn 2s cubic-bezier(0.22, 1, 0.36, 1);
    }

    @keyframes landingFadeIn {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .landing-inner h1 {
      font-family: 'Libre Baskerville', serif;
      font-size: 4.5rem;
      font-weight: 400;
      margin-bottom: 20px;
      background: linear-gradient(135deg, #ffd700, #ff8c00, #ff6b9d);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: 2px;
      animation: titleGlow 3s ease-in-out infinite alternate;
    }

    @keyframes titleGlow {
      from {
        filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.3));
      }
      to {
        filter: drop-shadow(0 0 40px rgba(255, 140, 0, 0.5));
      }
    }

    .landing-inner p {
      font-size: 1.4rem;
      line-height: 2;
      opacity: 0.9;
      margin-bottom: 50px;
      font-style: italic;
    }

    #enter {
      padding: 18px 48px;
      border-radius: 50px;
      border: 2px solid rgba(255, 215, 0, 0.5);
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 140, 0, 0.1));
      backdrop-filter: blur(10px);
      color: #ffd700;
      font-size: 1.2rem;
      font-family: 'Libre Baskerville', serif;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
      position: relative;
      overflow: hidden;
    }

    #enter::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 140, 0, 0.2));
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    #enter:hover::before {
      opacity: 1;
    }

    #enter:hover {
      transform: scale(1.05);
      border-color: rgba(255, 215, 0, 0.8);
      box-shadow: 0 10px 40px rgba(255, 215, 0, 0.3);
    }

    /* SPACE PAGE */
    #spacePage {
      background: transparent;
    }

    #space {
      position: fixed;
      inset: 0;
      display: block;
    }

    /* MESSAGE CARD */
    #card {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(15, 10, 30, 0.95), rgba(0, 0, 0, 0.98));
      backdrop-filter: blur(30px);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 50px;
      text-align: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transform: scale(0.9);
      transition: all 1s cubic-bezier(0.22, 1, 0.36, 1);
    }

    #card.active {
      opacity: 1;
      pointer-events: auto;
      transform: scale(1);
    }

    #card h2 {
      font-family: 'Libre Baskerville', serif;
      font-size: 3.2rem;
      margin-bottom: 30px;
      letter-spacing: 3px;
      text-transform: uppercase;
      animation: cardTitleFloat 3s ease-in-out infinite;
    }

    @keyframes cardTitleFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    #card p {
      max-width: 560px;
      font-size: 1.35rem;
      line-height: 2.2;
      white-space: pre-line;
      opacity: 0.95;
    }

    #close {
      position: absolute;
      top: 40px;
      right: 40px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      color: white;
      font-size: 1.8rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    #close:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
      transform: rotate(90deg);
    }

    /* Final Message */
    .final-unlock {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle, rgba(255, 215, 0, 0.2), transparent);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s ease;
    }

    .final-unlock.show {
      opacity: 1;
      animation: finalPulse 2s ease-in-out;
    }

    @keyframes finalPulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.1); }
    }

    .final-unlock h3 {
      font-size: 2rem;
      color: #ffd700;
      margin-bottom: 15px;
    }

    /* Meteor Shower Finale */
    .meteor-shower-announcement {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle, rgba(255, 215, 0, 0.15), transparent);
      padding: 50px;
      border-radius: 30px;
      text-align: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s ease;
    }

    .meteor-shower-announcement.show {
      opacity: 1;
      animation: announcementPulse 2s ease-in-out;
    }

    @keyframes announcementPulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.1); }
    }

    .meteor-shower-announcement h2 {
      font-family: 'Libre Baskerville', serif;
      font-size: 2.5rem;
      color: #ffd700;
      margin-bottom: 20px;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
    }

    .meteor-shower-announcement p {
      font-family: 'Crimson Text', serif;
      font-size: 1.5rem;
      color: #ffffff;
      font-style: italic;
    }

    /* Meteor styles */
    .meteor {
      position: fixed;
      pointer-events: none;
      z-index: 500;
    }

    .meteor-trail {
      position: absolute;
      width: 200px;
      height: 3px;
      background: linear-gradient(to right, rgba(255, 255, 255, 0.9), rgba(255, 235, 59, 0.6), transparent);
      box-shadow: 0 0 10px rgba(255, 235, 59, 0.8);
      transform-origin: left center;
    }

    .meteor-head {
      position: absolute;
      width: 8px;
      height: 8px;
      background: radial-gradient(circle, #ffffff, #ffeb3b);
      border-radius: 50%;
      box-shadow: 0 0 20px 5px rgba(255, 255, 255, 0.8),
                  0 0 40px 10px rgba(255, 235, 59, 0.6);
      left: 0;
      top: 50%;
      transform: translateY(-50%);
    }

    .meteor-word {
      position: absolute;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      font-family: 'Libre Baskerville', serif;
      font-size: 2rem;
      font-weight: bold;
      color: #ffffff;
      text-shadow: 
        0 0 10px rgba(255, 235, 59, 1),
        0 0 20px rgba(255, 193, 7, 0.8),
        0 0 30px rgba(255, 152, 0, 0.6);
      white-space: nowrap;
      animation: wordGlow 1s ease-in-out infinite alternate;
    }

    @keyframes wordGlow {
      0% { 
        text-shadow: 
          0 0 10px rgba(255, 235, 59, 1),
          0 0 20px rgba(255, 193, 7, 0.8),
          0 0 30px rgba(255, 152, 0, 0.6);
      }
      100% { 
        text-shadow: 
          0 0 20px rgba(255, 235, 59, 1),
          0 0 40px rgba(255, 193, 7, 1),
          0 0 60px rgba(255, 152, 0, 0.8);
      }
    }

    @keyframes meteorFall {
      0% {
        opacity: 0;
        transform: translate(0, 0) rotate(-45deg);
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform: translate(-600px, 600px) rotate(-45deg);
      }
    }

    /* Final Message After Meteor Shower */
    .finale-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.8);
        background: radial-gradient(ellipse at center, rgba(15, 10, 30, 0.98), rgba(0, 0, 0, 1));
        backdrop-filter: blur(30px);
        border: 4px solid rgba(255, 215, 0, 0.8);
        border-radius: 30px;
        padding: 60px;
        max-width: 700px;
        text-align: center;
        z-index: 10002;
        opacity: 0;
        pointer-events: none;
        transition: all 1.5s cubic-bezier(0.22, 1, 0.36, 1);
        box-shadow: 0 0 80px rgba(255, 215, 0, 0.6);
      }

    .finale-message.show {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }

    .finale-message h2 {
      font-family: 'Libre Baskerville', serif;
      font-size: 3rem;
      color: #ffd700;
      margin-bottom: 30px;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
      animation: cardTitleFloat 3s ease-in-out infinite;
    }

    .finale-message p {
      font-family: 'Crimson Text', serif;
      font-size: 1.5rem;
      line-height: 2.2;
      color: #ffffff;
      margin-bottom: 40px;
      white-space: pre-line;
    }

    .finale-message button {
      padding: 18px 45px;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 140, 0, 0.3));
      border: 3px solid rgba(255, 215, 0, 0.6);
      border-radius: 35px;
      color: #ffd700;
      font-size: 1.3rem;
      font-family: 'Libre Baskerville', serif;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .finale-message button:hover {
      transform: scale(1.1);
      box-shadow: 0 10px 40px rgba(255, 215, 0, 0.5);
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.4), rgba(255, 140, 0, 0.4));
    }

    /* Easter Egg - Shooting Stars */
    .shooting-star {
      position: fixed;
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      z-index: 9999;
      cursor: pointer !important;
      pointer-events: auto !important;
    }

    .shooting-star-core {
      width: 8px;
      height: 8px;
      background: radial-gradient(circle, #ffffff 0%, #ffeb3b 50%, transparent 100%);
      border-radius: 50%;
      box-shadow: 
        0 0 20px 4px rgba(255, 255, 255, 1),
        0 0 40px 8px rgba(255, 235, 59, 0.8),
        0 0 60px 12px rgba(255, 193, 7, 0.6);
      filter: brightness(1.5);
      position: absolute;
    }

    .shooting-star-core::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 150px;
      height: 4px;
      background: linear-gradient(to right, rgba(255, 255, 255, 0.9), rgba(255, 235, 59, 0.6), transparent);
      transform: translate(-50%, -50%) rotate(-45deg);
      filter: blur(1px);
    }

    .shooting-star-icon {
      font-size: 35px;
      filter: drop-shadow(0 0 15px rgba(255, 235, 59, 1));
      position: absolute;
      animation: starPulse 0.5s ease-in-out infinite alternate;
    }

    .shooting-star:hover {
      transform: scale(1.3) !important;
    }

    .shooting-star:hover .shooting-star-icon {
      font-size: 45px;
      filter: drop-shadow(0 0 25px rgba(255, 235, 59, 1));
    }

    @keyframes starPulse {
      0% { transform: scale(1); }
      100% { transform: scale(1.15); }
    }

    @keyframes shootingStar {
      0% {
        opacity: 1;
        transform: translate(0, 0) scale(1);
      }
      100% {
        opacity: 0.3;
        transform: translate(-400px, 400px) scale(0.8);
      }
    }

    /* Easter Egg Notification */
    .easter-egg-hint {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(10, 5, 30, 0.95);
      backdrop-filter: blur(20px);
      border: 3px solid rgba(255, 215, 0, 0.7);
      border-radius: 25px;
      padding: 20px 40px;
      color: #ffd700;
      font-size: 1.2rem;
      font-family: 'Crimson Text', serif;
      z-index: 999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
      text-align: center;
      box-shadow: 0 0 40px rgba(255, 215, 0, 0.4);
    }

    .easter-egg-hint.show {
      opacity: 1;
      animation: hintPulse 2s ease-in-out infinite;
    }

    @keyframes hintPulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.05); }
    }

    /* Responsive */
    @media (max-width: 768px) {
      body {
        cursor: auto;
      }
      
      #cursor {
        display: none;
      }
      
      .landing-inner h1 { 
        font-size: 2.5rem;
      }
      
      .landing-inner p { 
        font-size: 1rem;
        line-height: 1.6;
      }
      
      #enter {
        font-size: 1rem;
        padding: 14px 36px;
      }
      
      #card h2 { 
        font-size: 1.8rem;
        letter-spacing: 1px;
      }
      
      #card p { 
        font-size: 1rem;
        line-height: 1.8;
        padding: 0 10px;
      }
      
      #close {
        top: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        font-size: 1.4rem;
      }

      .easter-egg-hint {
        bottom: 20px;
        font-size: 0.9rem;
        padding: 12px 20px;
      }

      .meteor-word {
        font-size: 1.3rem;
      }

      .meteor-shower-announcement h2 {
        font-size: 1.8rem;
      }

      .meteor-shower-announcement p {
        font-size: 1.2rem;
      }

      .finale-message {
        padding: 40px 30px;
        max-width: 90%;
      }

      .finale-message h2 {
        font-size: 2rem;
      }

      .finale-message p {
        font-size: 1.1rem;
        line-height: 1.8;
      }

      .finale-message button {
        font-size: 1.1rem;
        padding: 15px 35px;
      }
    }
  </style>
</head>
<body>

  <!-- Custom Cursor -->
  <div id="cursor"></div>

  <!-- LANDING -->
  <section id="landing" class="page active">
    <div class="stars-bg"></div>
    <div class="landing-inner">
      <h1>My Solar System</h1>
      <p>
        I've created a universe just for you.<br />
        Eight planets, each holding a piece of my heart,<br />
        orbiting around the warmth of everything I feel.
      </p>
      <button id="enter">Enter the System</button>
    </div>
  </section>

  <!-- SPACE -->
  <section id="spacePage" class="page">
    <canvas id="space"></canvas>
  </section>

  <!-- MESSAGE CARD -->
  <div id="card">
    <button id="close">âœ•</button>
    <h2 id="cardTitle"></h2>
    <p id="cardText"></p>
  </div>

  <!-- Final Unlock Message -->
  <div class="final-unlock" id="finalUnlock">
    <h3>âœ¨ All Planets Discovered âœ¨</h3>
    <p>The Sun now glows brighter, just for you</p>
  </div>

  <!-- Meteor Shower Finale -->
  <div class="meteor-shower-announcement" id="meteorAnnouncement">
    <h2>ðŸŒ  Preparing Something Special ðŸŒ </h2>
    <p>Watch the sky...</p>
  </div>

  <!-- Finale Message -->
  <div class="finale-message .show" id="finaleMessage">
    <h2>ðŸ’« HRITU ðŸ’«</h2>
    <p>Every meteor that fell was a moment
I fell deeper in love with you.

You are my universe, my infinity,
my forever.

Thank you for letting me orbit your heart.

I LOVE YOU MORE THAN ALL THE STARS âœ¨

- SONY</p>
    <button id="closeFinale">Forever Yours ðŸ’›</button>
  </div>

  <!-- Easter Egg Hint -->
  <div class="easter-egg-hint" id="easterEggHint">
    ðŸ’« Look for shooting stars! Click them for a surprise... ðŸ’«
  </div>

  <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
  <script>
    // Load OrbitControls after Three.js is loaded
    const script = document.createElement('script');
    script.src = 'https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js';
    script.onload = initScene;
    script.onerror = function() {
      console.error('Failed to load OrbitControls');
      initScene();
    };
    document.head.appendChild(script);
    
    function initScene() {
    if (typeof THREE === 'undefined') {
      console.error('THREE.js failed to load');
      alert('Failed to load 3D library. Please refresh the page.');
      return;
    }
    
    // Custom Cursor
    const cursor = document.getElementById('cursor');
    let mouseX = 0, mouseY = 0;

    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    function animateCursor() {
      cursor.style.left = mouseX + 'px';
      cursor.style.top = mouseY + 'px';
      requestAnimationFrame(animateCursor);
    }
    animateCursor();

    // Page Transition
    const landing = document.getElementById("landing");
    const spacePage = document.getElementById("spacePage");
    const enterBtn = document.getElementById("enter");

    enterBtn.addEventListener("mouseenter", () => cursor.classList.add("hovering"));
    enterBtn.addEventListener("mouseleave", () => cursor.classList.remove("hovering"));

    enterBtn.addEventListener("click", () => {
      landing.classList.remove("active");
      setTimeout(() => {
        spacePage.classList.add("active");
        // Start shooting stars immediately when entering space
        setTimeout(() => startShootingStars(), 2000);
      }, 100);
    });

    // THREE.JS SETUP
    const canvas = document.getElementById("space");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 10, 80);

    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 15, 45);

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true
    });

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // ORBIT CONTROLS
    let controls;
    if (typeof THREE.OrbitControls !== 'undefined') {
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 10;
      controls.maxDistance = 150;
      controls.maxPolarAngle = Math.PI;
      controls.enablePan = true;
      controls.panSpeed = 0.8;
      controls.rotateSpeed = 0.6;
      controls.zoomSpeed = 1.2;
      controls.autoRotate = false;
      controls.autoRotateSpeed = 0.5;
    }

    // LIGHTING
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
    scene.add(ambientLight);

    const sunLight = new THREE.PointLight(0xffa500, 3, 100);
    sunLight.position.set(0, 0, 0);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    scene.add(sunLight);

    // ENHANCED REALISTIC STARFIELD with proper twinkling
    function createRealisticStarfield() {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const colors = [];
      const sizes = [];

      // Create different star populations
      const starPopulations = [
        { count: 8000, sizeRange: [0.15, 0.4], brightness: [0.7, 1.0], colorTemp: 'cool' }, // Distant stars
        { count: 3000, sizeRange: [0.4, 0.8], brightness: [0.8, 1.0], colorTemp: 'warm' }, // Mid-distance
        { count: 1500, sizeRange: [0.8, 1.5], brightness: [0.9, 1.0], colorTemp: 'hot' },  // Bright nearby
        { count: 500, sizeRange: [1.5, 2.5], brightness: [1.0, 1.0], colorTemp: 'variable' } // Very bright
      ];

      starPopulations.forEach(pop => {
        for (let i = 0; i < pop.count; i++) {
          // More natural distribution - avoid clustering
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);
          const radius = 200 + Math.random() * 300;
          
          const x = radius * Math.sin(phi) * Math.cos(theta);
          const y = radius * Math.sin(phi) * Math.sin(theta);
          const z = radius * Math.cos(phi);
          
          vertices.push(x, y, z);

          // Realistic star colors based on temperature
          const color = new THREE.Color();
          const brightness = pop.brightness[0] + Math.random() * (pop.brightness[1] - pop.brightness[0]);
          
          switch(pop.colorTemp) {
            case 'cool': // Red/Orange stars (cooler)
              color.setHSL(0.05 + Math.random() * 0.05, 0.6, brightness * 0.5);
              break;
            case 'warm': // Yellow/White stars
              color.setHSL(0.15 + Math.random() * 0.05, 0.2, brightness * 0.7);
              break;
            case 'hot': // Blue/White stars (hotter)
              color.setHSL(0.55 + Math.random() * 0.1, 0.4, brightness * 0.8);
              break;
            case 'variable': // Mix of all types
              const type = Math.random();
              if (type < 0.3) {
                color.setHSL(0.05, 0.7, brightness * 0.6); // Red giant
              } else if (type < 0.6) {
                color.setHSL(0.15, 0.1, brightness * 0.9); // White
              } else {
                color.setHSL(0.6, 0.5, brightness * 0.85); // Blue
              }
              break;
          }
          
          colors.push(color.r, color.g, color.b);
          
          const size = pop.sizeRange[0] + Math.random() * (pop.sizeRange[1] - pop.sizeRange[0]);
          sizes.push(size);
        }
      });

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

      // Custom shader for realistic star rendering with twinkling
      const starMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 }
        },
        vertexShader: `
          attribute float size;
          attribute vec3 color;
          varying vec3 vColor;
          varying float vSize;
          uniform float time;
          
          void main() {
            vColor = color;
            vSize = size;
            
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            
            // Subtle twinkling effect based on position
            float twinkle = sin(time * 2.0 + position.x * 0.1 + position.y * 0.1) * 0.3 + 0.7;
            
            gl_PointSize = size * twinkle * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          varying float vSize;
          
          void main() {
            // Create soft, realistic star glow
            vec2 center = gl_PointCoord - vec2(0.5);
            float dist = length(center);
            
            // Soft falloff with bright center
            float intensity = 1.0 - smoothstep(0.0, 0.5, dist);
            intensity = pow(intensity, 1.5);
            
            // Add bright core for larger stars
            if (vSize > 1.0) {
              float core = 1.0 - smoothstep(0.0, 0.2, dist);
              intensity += core * 0.5;
            }
            
            gl_FragColor = vec4(vColor, intensity);
          }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      const stars = new THREE.Points(geometry, starMaterial);
      stars.userData.material = starMaterial; // Store reference for animation
      return stars;
    }

    const starfield = createRealisticStarfield();
    scene.add(starfield);

    // ENHANCED MILKY WAY GALAXY
    function createMilkyWay() {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const colors = [];
      const sizes = [];

      for (let i = 0; i < 25000; i++) {
        const angle = Math.random() * Math.PI * 2;
        const armOffset = Math.floor(Math.random() * 4) * (Math.PI * 2 / 4);
        const radius = Math.pow(Math.random(), 0.5) * 180 + 40;
        const spiral = angle + armOffset + radius * 0.03;
        
        const spreadX = (Math.random() - 0.5) * (100 - radius * 0.3);
        const spreadZ = (Math.random() - 0.5) * (100 - radius * 0.3);
        
        const x = Math.cos(spiral) * radius + spreadX;
        const y = (Math.random() - 0.5) * (20 - radius * 0.08);
        const z = Math.sin(spiral) * radius + spreadZ;
        
        vertices.push(x, y, z);

        const color = new THREE.Color();
        const colorChoice = Math.random();
        const distFromCenter = radius / 180;
        
        if (colorChoice < 0.25) {
          color.setHSL(0.6, 0.6, Math.random() * 0.3 + 0.3 + distFromCenter * 0.1);
        } else if (colorChoice < 0.5) {
          color.setHSL(0.75, 0.5, Math.random() * 0.3 + 0.35);
        } else if (colorChoice < 0.75) {
          color.setHSL(0.55, 0.2, Math.random() * 0.4 + 0.5);
        } else {
          color.setHSL(0.15, 0.4, Math.random() * 0.3 + 0.4);
        }
        colors.push(color.r, color.g, color.b);

        const sizeVariation = Math.random() * 0.6 + 0.2;
        sizes.push(sizeVariation * (1 - distFromCenter * 0.5));
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

      const material = new THREE.PointsMaterial({
        size: 0.4,
        vertexColors: true,
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
      });

      const milkyWay = new THREE.Points(geometry, material);
      milkyWay.rotation.x = Math.PI / 5;
      milkyWay.rotation.z = Math.PI / 8;
      return milkyWay;
    }

    const milkyWay = createMilkyWay();
    scene.add(milkyWay);

    // NEBULA CLOUDS
    function createNebulaClouds() {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const colors = [];
      const sizes = [];

      for (let i = 0; i < 3000; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 200 + 100;
        
        const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 80;
        const y = (Math.random() - 0.5) * 150;
        const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 80;
        
        vertices.push(x, y, z);

        const color = new THREE.Color();
        const colorType = Math.random();
        if (colorType < 0.4) {
          color.setHSL(0.6, 0.7, 0.3);
        } else if (colorType < 0.7) {
          color.setHSL(0.85, 0.6, 0.35);
        } else {
          color.setHSL(0.0, 0.7, 0.3);
        }
        colors.push(color.r, color.g, color.b);
        sizes.push(Math.random() * 2.5 + 1.5);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

      const material = new THREE.PointsMaterial({
        size: 3.0,
        vertexColors: true,
        transparent: true,
        opacity: 0.15,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
      });

      return new THREE.Points(geometry, material);
    }

    const nebulaClouds = createNebulaClouds();
    scene.add(nebulaClouds);

    // SUN
    const sunGeometry = new THREE.SphereGeometry(4.5, 128, 128);
    
    function createSunTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
      gradient.addColorStop(0, '#fff4e6');
      gradient.addColorStop(0.3, '#ffcc00');
      gradient.addColorStop(0.6, '#ff8c00');
      gradient.addColorStop(1, '#ff4500');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 512, 512);
      
      for (let i = 0; i < 200; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const size = Math.random() * 30 + 10;
        const opacity = Math.random() * 0.3 + 0.1;
        
        const flareGradient = ctx.createRadialGradient(x, y, 0, x, y, size);
        flareGradient.addColorStop(0, `rgba(255, 255, 200, ${opacity})`);
        flareGradient.addColorStop(0.5, `rgba(255, 200, 100, ${opacity * 0.5})`);
        flareGradient.addColorStop(1, 'rgba(255, 140, 0, 0)');
        
        ctx.fillStyle = flareGradient;
        ctx.fillRect(x - size, y - size, size * 2, size * 2);
      }
      
      return new THREE.CanvasTexture(canvas);
    }
    
    const sunMaterial = new THREE.MeshStandardMaterial({
      color: 0xffaa00,
      emissive: 0xff6600,
      emissiveIntensity: 2.0,
      emissiveMap: createSunTexture(),
      roughness: 1.0,
      metalness: 0
    });

    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    sun.castShadow = false;
    sun.receiveShadow = false;
    
    sun.userData = {
      name: "SUN",
      isSun: true,
      text: `HRITU,

You are the center of my universe,
the warmth that lights up every corner of my existence.

Everything I am orbits around the love I have for you.

I LOVE YOU â¤ï¸
- SONY`
    };
    
    scene.add(sun);

    const glowGeometry = new THREE.SphereGeometry(5.5, 64, 64);
    const glowMaterial = new THREE.ShaderMaterial({
      uniforms: {
        glowColor: { value: new THREE.Color(0xffaa00) },
        intensity: { value: 0.8 }
      },
      vertexShader: `
        varying vec3 vNormal;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 glowColor;
        uniform float intensity;
        varying vec3 vNormal;
        void main() {
          float brightness = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.5);
          gl_FragColor = vec4(glowColor, 1.0) * brightness * intensity;
        }
      `,
      side: THREE.BackSide,
      blending: THREE.AdditiveBlending,
      transparent: true
    });
    const sunGlow = new THREE.Mesh(glowGeometry, glowMaterial);
    sun.add(sunGlow);

    // CREATE PLANET TEXTURES
    function createPlanetTexture(color, type) {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      const baseColor = new THREE.Color(color);
      ctx.fillStyle = `rgb(${baseColor.r * 255}, ${baseColor.g * 255}, ${baseColor.b * 255})`;
      ctx.fillRect(0, 0, 512, 512);
      
      if (type === 'rocky') {
        for (let i = 0; i < 150; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const size = Math.random() * 20 + 5;
          const darkness = Math.random() * 0.3;
          
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
          gradient.addColorStop(0, `rgba(0, 0, 0, ${darkness})`);
          gradient.addColorStop(0.7, `rgba(0, 0, 0, ${darkness * 0.3})`);
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(x - size, y - size, size * 2, size * 2);
        }
        
        for (let i = 0; i < 80; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const size = Math.random() * 15 + 3;
          const brightness = Math.random() * 0.2;
          
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
          gradient.addColorStop(0, `rgba(255, 255, 255, ${brightness})`);
          gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(x - size, y - size, size * 2, size * 2);
        }
      } else if (type === 'gas') {
        for (let y = 0; y < 512; y++) {
          const wave = Math.sin(y * 0.02) * 10;
          const wave2 = Math.sin(y * 0.05) * 5;
          const opacity = (Math.sin(y * 0.015) + 1) * 0.15;
          
          ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
          ctx.fillRect(0, y + wave + wave2, 512, 1);
          
          ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.5})`;
          ctx.fillRect(0, y + wave - wave2, 512, 1);
        }
        
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const size = Math.random() * 30 + 15;
          
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
          gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
          gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
          gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.ellipse(x, y, size * 1.5, size, Math.random() * Math.PI, 0, Math.PI * 2);
          ctx.fill();
        }
      } else if (type === 'ice') {
        for (let i = 0; i < 100; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const size = Math.random() * 25 + 10;
          
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
          gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
          gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(x - size, y - size, size * 2, size * 2);
        }
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 50; i++) {
          ctx.beginPath();
          let x = Math.random() * 512;
          let y = Math.random() * 512;
          ctx.moveTo(x, y);
          
          for (let j = 0; j < 5; j++) {
            x += (Math.random() - 0.5) * 40;
            y += (Math.random() - 0.5) * 40;
            ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
      } else if (type === 'volcanic') {
        for (let i = 0; i < 120; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const size = Math.random() * 20 + 5;
          
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
          gradient.addColorStop(0, 'rgba(255, 100, 0, 0.5)');
          gradient.addColorStop(0.5, 'rgba(200, 50, 0, 0.3)');
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(x - size, y - size, size * 2, size * 2);
        }
        
        for (let i = 0; i < 80; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const size = Math.random() * 30 + 10;
          
          ctx.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.4 + 0.2})`;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      const imageData = ctx.getImageData(0, 0, 512, 512);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const noise = (Math.random() - 0.5) * 10;
        data[i] += noise;
        data[i + 1] += noise;
        data[i + 2] += noise;
      }
      ctx.putImageData(imageData, 0, 0);
      
      return new THREE.CanvasTexture(canvas);
    }
    
    function createBumpMap(type) {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = '#808080';
      ctx.fillRect(0, 0, 512, 512);
      
      if (type === 'rocky' || type === 'volcanic') {
        for (let i = 0; i < 200; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const size = Math.random() * 15 + 5;
          const brightness = Math.random() * 100 + 100;
          
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
          gradient.addColorStop(0, `rgb(${brightness}, ${brightness}, ${brightness})`);
          gradient.addColorStop(1, '#808080');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(x - size, y - size, size * 2, size * 2);
        }
      } else if (type === 'gas') {
        for (let y = 0; y < 512; y++) {
          const wave = Math.sin(y * 0.03) * 20;
          const brightness = 128 + wave;
          ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
          ctx.fillRect(0, y, 512, 1);
        }
      }
      
      return new THREE.CanvasTexture(canvas);
    }
    
    function createCloudTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      ctx.clearRect(0, 0, 512, 512);
      
      for (let i = 0; i < 100; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const size = Math.random() * 40 + 20;
        const opacity = Math.random() * 0.3 + 0.1;
        
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
        gradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity * 0.5})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(x - size, y - size, size * 2, size * 2);
      }
      
      return new THREE.CanvasTexture(canvas);
    }

    // PLANET DATA
    const planetData = [
      {
        name: "HAPPY",
        color: 0xffeb3b,
        emissive: 0xffc107,
        size: 0.8,
        distance: 8,
        speed: 0.8,
        type: 'volcanic',
        text: `When you are happy,
the whole universe brightens.

Your joy is contagious,
your laughter echoes through galaxies.

I love existing in the same orbit as your happiness.`
      },
      {
        name: "CALM",
        color: 0x64b5f6,
        emissive: 0x2196f3,
        size: 0.9,
        distance: 11,
        speed: 0.65,
        type: 'ice',
        text: `With you, everything slows down.

You are my peaceful orbit,
the center where chaos fades.

In your presence, I find stillness
that the universe envies.`
      },
      {
        name: "EXCITED",
        color: 0xff6f00,
        emissive: 0xff5722,
        size: 0.75,
        distance: 14,
        speed: 1.2,
        type: 'volcanic',
        text: `Your excitement is magnetic,
pulling in stardust and possibility.

When you're thrilled, the cosmos dances,
and I can't help but spin faster too.

Energy like yours lights up worlds.`
      },
      {
        name: "ROMANTIC",
        color: 0xf48fb1,
        emissive: 0xe91e63,
        size: 1.0,
        distance: 17,
        speed: 0.5,
        type: 'gas',
        text: `I would find you in every galaxy,
across infinite timelines.

Love is the gravity that keeps me
forever drawn to you.

You are my celestial constant.`
      },
      {
        name: "ANXIOUS",
        color: 0x9575cd,
        emissive: 0x673ab7,
        size: 0.7,
        distance: 20,
        speed: 0.9,
        type: 'rocky',
        text: `When worry storms through you,
remember you're not adrift.

I'm here, a steady moon,
reflecting light even in darkness.

Together, we weather any turbulence.`
      },
      {
        name: "CREATIVE",
        color: 0x26c6da,
        emissive: 0x00bcd4,
        size: 0.85,
        distance: 23,
        speed: 0.7,
        type: 'gas',
        text: `Your imagination builds universes,
paints nebulas with possibility.

Every idea you birth
adds color to existence.

Create freelyâ€”I'm in awe of your cosmos.`
      },
      {
        name: "GRATEFUL",
        color: 0x66bb6a,
        emissive: 0x4caf50,
        size: 0.8,
        distance: 26,
        speed: 0.6,
        type: 'rocky',
        text: `Gratitude is the light you carry,
warming every space you enter.

Thank you for sharing your orbit,
for letting me witness your wonder.

I'm grateful the universe brought us here.`
      },
      {
        name: "OVERWHELMED",
        color: 0xef5350,
        emissive: 0xf44336,
        size: 0.9,
        distance: 29,
        speed: 0.55,
        type: 'volcanic',
        text: `If the weight of worlds feels too heavy,
let me share the load.

You don't have to carry everything alone.
Rest in this orbitâ€”you're safe here.

Together, we're stronger than any storm.`
      }
    ];

    // CREATE PLANETS
    const planets = [];
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function createPlanetLabel(text) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = 512;
      canvas.height = 128;

      ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
      ctx.shadowColor = "rgba(0, 0, 0, 0.9)";
      ctx.shadowBlur = 20;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "rgba(255, 215, 0, 0.4)";
      ctx.lineWidth = 3;
      ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);

      ctx.shadowColor = "rgba(255, 255, 255, 0.8)";
      ctx.shadowBlur = 15;

      ctx.font = "bold 48px 'Libre Baskerville', serif";
      ctx.fillStyle = "#ffffff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      ctx.strokeStyle = "#ffd700";
      ctx.lineWidth = 2;
      ctx.strokeText(text, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        opacity: 0.95,
        depthTest: false,
        depthWrite: false
      });

      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(5, 1.25, 1);
      sprite.position.set(0, 2.5, 0);
      sprite.renderOrder = 1000;

      return sprite;
    }

    planetData.forEach((data, index) => {
      const geometry = new THREE.SphereGeometry(data.size, 128, 128);
      
      const texture = createPlanetTexture(data.color, data.type);
      const bumpMap = createBumpMap(data.type);
      
      const material = new THREE.MeshStandardMaterial({
        map: texture,
        bumpMap: bumpMap,
        bumpScale: 0.05,
        color: 0xffffff,
        emissive: data.emissive,
        emissiveIntensity: 0.3,
        roughness: data.type === 'ice' ? 0.3 : (data.type === 'gas' ? 0.7 : 0.8),
        metalness: data.type === 'ice' ? 0.2 : 0.1
      });

      const planet = new THREE.Mesh(geometry, material);
      planet.castShadow = true;
      planet.receiveShadow = true;

      planet.userData = {
        ...data,
        index: index,
        angle: (Math.PI * 2 / planetData.length) * index,
        baseY: Math.sin(index * 0.5) * 2,
        opened: false,
        isHovered: false
      };

      const atmosphereGeometry = new THREE.SphereGeometry(data.size * 1.15, 64, 64);
      const atmosphereMaterial = new THREE.MeshBasicMaterial({
        color: data.color,
        transparent: true,
        opacity: 0.2,
        side: THREE.BackSide
      });
      const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
      planet.add(atmosphere);
      planet.userData.atmosphere = atmosphere;

      if (data.type === 'gas') {
        const cloudGeometry = new THREE.SphereGeometry(data.size * 1.05, 64, 64);
        const cloudTexture = createCloudTexture();
        const cloudMaterial = new THREE.MeshStandardMaterial({
          map: cloudTexture,
          transparent: true,
          opacity: 0.4,
          depthWrite: false
        });
        const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
        planet.add(clouds);
        planet.userData.clouds = clouds;
      }

      const ringGeometry = new THREE.SphereGeometry(data.size * 1.3, 64, 64);
      const ringMaterial = new THREE.MeshBasicMaterial({
        color: data.color,
        transparent: true,
        opacity: 0,
        side: THREE.BackSide
      });
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      planet.add(ring);
      planet.userData.ring = ring;

      planet.add(createPlanetLabel(data.name));
      planets.push(planet);
      scene.add(planet);
    });

    // METEOR SHOWER FINALE
    const meteorAnnouncement = document.getElementById('meteorAnnouncement');
    const finaleMessage = document.getElementById('finaleMessage');
    
    function startMeteorShower() {
      // Show announcement
      meteorAnnouncement.classList.add('show');
      
      setTimeout(() => {
        meteorAnnouncement.classList.remove('show');
        
        // Start the meteor shower
        setTimeout(() => {
          launchMeteorShower();
        }, 500);
      }, 2500);
    }
    
    function launchMeteorShower() {
      const words = [
        'I', 'LOVE', 'YOU', 'FOREVER', 'HRITU',
        'MY', 'UNIVERSE', 'ALWAYS', 'INFINITE', 'LOVE',
        'YOU', 'ARE', 'MY', 'EVERYTHING', 'â¤ï¸',
        'FOREVER', 'YOURS', 'SONY', 'âœ¨', 'TOGETHER'
      ];
      
      let meteorCount = 0;
      const totalMeteors = words.length;
      
      const meteorInterval = setInterval(() => {
        if (meteorCount >= totalMeteors) {
          clearInterval(meteorInterval);
          // Show finale message after all meteors
          setTimeout(() => {
            finaleMessage.classList.add('show');
          }, 2000);
          return;
        }
        
        createMeteor(words[meteorCount]);
        meteorCount++;
      }, 400); // Meteor every 400ms
    }
    
    function createMeteor(word) {
      const meteor = document.createElement('div');
      meteor.className = 'meteor';
      
      const trail = document.createElement('div');
      trail.className = 'meteor-trail';
      
      const head = document.createElement('div');
      head.className = 'meteor-head';
      
      const wordElement = document.createElement('div');
      wordElement.className = 'meteor-word';
      wordElement.textContent = word;
      
      meteor.appendChild(trail);
      meteor.appendChild(head);
      meteor.appendChild(wordElement);
      
      // Random starting position along top and right edges
      const startSide = Math.random() > 0.6 ? 'top' : 'right';
      if (startSide === 'top') {
        meteor.style.left = (Math.random() * (window.innerWidth - 200)) + 'px';
        meteor.style.top = '-50px';
      } else {
        meteor.style.left = (window.innerWidth + 50) + 'px';
        meteor.style.top = (Math.random() * (window.innerHeight * 0.7)) + 'px';
      }
      
      document.body.appendChild(meteor);
      
      // Animate
      const duration = 3 + Math.random() * 2; // 3-5 seconds
      meteor.style.animation = `meteorFall ${duration}s ease-out forwards`;
      
      // Remove after animation
      setTimeout(() => {
        meteor.remove();
      }, duration * 1000);
    }
    
    // Close finale message
    document.addEventListener('DOMContentLoaded', () => {
        const closeFinaleBtn = document.getElementById('closeFinale');
        const finaleMessage = document.getElementById('finaleMessage');
        const cursor = document.querySelector('.cursor'); // only if you actually have one
      
        if (closeFinaleBtn && finaleMessage) {
      
          closeFinaleBtn.addEventListener('mouseenter', () => {
            if (cursor) cursor.classList.add('hovering');
          });
      
          closeFinaleBtn.addEventListener('mouseleave', () => {
            if (cursor) cursor.classList.remove('hovering');
          });
      
          closeFinaleBtn.addEventListener('click', () => {
            finaleMessage.classList.remove('show');
      
            
          });
        }
      });
      
    // INTERACTION
    let focusedPlanet = null;
    let hoveredPlanet = null;
    let openedCount = 0;
    const card = document.getElementById("card");
    const cardTitle = document.getElementById("cardTitle");
    const cardText = document.getElementById("cardText");
    const closeBtn = document.getElementById("close");
    const finalUnlock = document.getElementById("finalUnlock");
    const easterEggHint = document.getElementById("easterEggHint");

    // EASTER EGG - Shooting Stars System
    let shootingStarsActive = false;
    let shootingStarsFound = 0;
    const totalShootingStars = 5;
    const shootingStarElements = [];

    function createShootingStar() {
      if (!shootingStarsActive) return;
      
      const star = document.createElement('div');
      star.className = 'shooting-star';
      
      // Add inner elements
      const core = document.createElement('div');
      core.className = 'shooting-star-core';
      
      const icon = document.createElement('div');
      icon.className = 'shooting-star-icon';
      icon.textContent = 'â­';
      
      star.appendChild(core);
      star.appendChild(icon);
      
      // Random starting position along top and right edges
      const startSide = Math.random() > 0.5 ? 'top' : 'right';
      if (startSide === 'top') {
        star.style.left = (Math.random() * (window.innerWidth - 100)) + 'px';
        star.style.top = '-80px';
      } else {
        star.style.left = window.innerWidth + 'px';
        star.style.top = (Math.random() * (window.innerHeight - 100)) + 'px';
      }
      
      document.body.appendChild(star);
      shootingStarElements.push(star);
      
      // Animate with longer duration
      star.style.animation = 'shootingStar 3s ease-out forwards';
      
      // Make sure cursor changes
      star.style.cursor = 'pointer';
      
      // Hover effect
      star.addEventListener('mouseenter', () => {
        cursor.classList.add('hovering');
      });
      
      star.addEventListener('mouseleave', () => {
        cursor.classList.remove('hovering');
      });
      
      // Click handler
      const clickHandler = (e) => {
        e.stopPropagation();
        e.preventDefault();
        
        star.remove();
        shootingStarsFound++;
        
        // Remove from array
        const index = shootingStarElements.indexOf(star);
        if (index > -1) shootingStarElements.splice(index, 1);
        
        // Enhanced visual feedback
        const sparkle = document.createElement('div');
        sparkle.style.cssText = `
          position: fixed;
          left: ${e.clientX || e.touches[0].clientX}px;
          top: ${e.clientY || e.touches[0].clientY}px;
          width: 60px;
          height: 60px;
          background: radial-gradient(circle, #ffeb3b, #ffc107, transparent);
          border-radius: 50%;
          pointer-events: none;
          z-index: 10001;
          animation: sparkleOut 0.8s ease-out forwards;
          box-shadow: 0 0 40px 15px rgba(255, 235, 59, 0.9);
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 40px;
        `;
        sparkle.textContent = 'âœ¨';
        document.body.appendChild(sparkle);
        setTimeout(() => sparkle.remove(), 800);
        
        // Show progress
        const progress = document.createElement('div');
        progress.style.cssText = `
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(10, 5, 30, 0.95);
          border: 3px solid rgba(255, 215, 0, 0.8);
          border-radius: 25px;
          padding: 15px 35px;
          color: #ffd700;
          font-size: 1.5rem;
          font-weight: bold;
          z-index: 10001;
          animation: fadeOut 2s ease-out forwards;
          box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        `;
        progress.textContent = `${shootingStarsFound} / ${totalShootingStars} â­`;
        document.body.appendChild(progress);
        setTimeout(() => progress.remove(), 2000);
        
        if (shootingStarsFound >= totalShootingStars) {
          unlockSecretMessage();
        }
      };
      
      star.addEventListener('click', clickHandler);
      star.addEventListener('touchstart', clickHandler, { passive: false });
      
      // Auto-remove after animation
      setTimeout(() => {
        if (star.parentNode) {
          star.remove();
          const index = shootingStarElements.indexOf(star);
          if (index > -1) shootingStarElements.splice(index, 1);
        }
      }, 3000);
    }

    // Add sparkle animation
    const style = document.createElement('style');
    style.textContent = `
      @keyframes sparkleOut {
        0% { transform: scale(1); opacity: 1; }
        100% { transform: scale(3); opacity: 0; }
      }
      @keyframes fadeOut {
        0% { opacity: 1; transform: translateX(-50%) translateY(0); }
        80% { opacity: 1; transform: translateX(-50%) translateY(0); }
        100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
      }
    `;
    document.head.appendChild(style);

    function startShootingStars() {
      shootingStarsActive = true;
      easterEggHint.classList.add('show');
      
      // Create shooting stars at shorter intervals for better visibility
      const shootingStarInterval = setInterval(() => {
        if (shootingStarsFound >= totalShootingStars) {
          clearInterval(shootingStarInterval);
          easterEggHint.classList.remove('show');
          shootingStarsActive = false;
          // Clean up any remaining stars
          shootingStarElements.forEach(star => star.remove());
          shootingStarElements.length = 0;
          return;
        }
        
        if (Math.random() > 0.2) { // 80% chance to spawn - more frequent!
          createShootingStar();
        }
      }, 1500); // Shorter interval - every 1.5 seconds
    }

    function unlockSecretMessage() {
        const secretCard = document.createElement('div');
      
        secretCard.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%) scale(0.8);
          background: radial-gradient(ellipse at center, rgba(15, 10, 30, 0.98), rgba(0, 0, 0, 1));
          backdrop-filter: blur(30px);
          border: 3px solid rgba(255, 215, 0, 0.6);
          border-radius: 30px;
          padding: 60px;
          max-width: 600px;
          text-align: center;
          z-index: 10001;
          opacity: 0;
          transition: all 1s cubic-bezier(0.22, 1, 0.36, 1);
          box-shadow: 0 0 60px rgba(255, 215, 0, 0.4);
        `;
      
        secretCard.innerHTML = `
          <h2 style="font-family: 'Libre Baskerville', serif; font-size: 2.5rem; color: #ffd700; margin-bottom: 30px; text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);">
            ðŸŒ  SECRET DISCOVERED ðŸŒ 
          </h2>
      
          <p style="font-family: 'Crimson Text', serif; font-size: 1.4rem; line-height: 2; color: #ffffff; margin-bottom: 40px;">
            You found all the shooting stars!<br/><br/>
            Just like you caught these fleeting moments,<br/>
            I want to catch every moment with you.<br/><br/>
            Every wish I make on a star<br/>
            has always been about you.<br/><br/>
            You ARE my wish come true. âœ¨
          </p>
      
          <button id="closeSecret"
            style="
              padding: 15px 40px;
              background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 140, 0, 0.2));
              border: 2px solid rgba(255, 215, 0, 0.5);
              border-radius: 30px;
              color: #ffd700;
              font-size: 1.1rem;
              font-family: 'Libre Baskerville', serif;
              cursor: pointer;
              transition: all 0.3s ease;
            ">
            Forever Grateful ðŸ’›
          </button>
        `;
      
      document.body.appendChild(secretCard);
      
      // Animate in
      setTimeout(() => {
        secretCard.style.opacity = '1';
        secretCard.style.transform = 'translate(-50%, -50%) scale(1)';
      }, 100);
      
      // Close button
      document.getElementById('closeSecret').addEventListener('click', () => {
        secretCard.style.opacity = '0';
        secretCard.style.transform = 'translate(-50%, -50%) scale(0.8)';
        setTimeout(() => secretCard.remove(), 1000);
      });
      
      // Hover effects
      const closeSecretBtn = document.getElementById('closeSecret');
      closeSecretBtn.addEventListener('mouseenter', () => {
        closeSecretBtn.style.transform = 'scale(1.05)';
        closeSecretBtn.style.boxShadow = '0 5px 20px rgba(255, 215, 0, 0.3)';
        cursor.classList.add('hovering');
      });
      closeSecretBtn.addEventListener('mouseleave', () => {
        closeSecretBtn.style.transform = 'scale(1)';
        closeSecretBtn.style.boxShadow = 'none';
        cursor.classList.remove('hovering');
      });
    }

    function handleClick(event) {
      if (card.classList.contains("active")) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      
      const allClickables = [sun, ...planets];
      const intersects = raycaster.intersectObjects(allClickables, false);

      if (intersects.length > 0) {
        focusedPlanet = intersects[0].object;
        const data = focusedPlanet.userData;

        cardTitle.textContent = data.name;
        cardText.textContent = data.text;
        
        if (data.isSun) {
          cardTitle.style.color = '#ffa500';
        } else {
          cardTitle.style.color = `#${new THREE.Color(data.color).getHexString()}`;
        }

        if (!data.opened && !data.isSun) {
          data.opened = true;
          openedCount++;

          if (openedCount === planetData.length) {
            setTimeout(() => {
              finalUnlock.classList.add('show');
              sunGlow.material.uniforms.intensity.value *= 1.5;
              setTimeout(() => {
                finalUnlock.classList.remove('show');
                // Start meteor shower finale
                setTimeout(() => startMeteorShower(), 1000);
              }, 3000);
            }, 1000);
          }
        }

        card.classList.add("active");
        cursor.classList.remove("hovering");
      }
    }

    canvas.addEventListener("click", handleClick);
    
    canvas.addEventListener("touchstart", (event) => {
      if (card.classList.contains("active")) return;
      
      event.preventDefault();
      
      const touch = event.touches[0];
      mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      
      const allClickables = [sun, ...planets];
      const intersects = raycaster.intersectObjects(allClickables, false);

      if (intersects.length > 0) {
        focusedPlanet = intersects[0].object;
        const data = focusedPlanet.userData;

        cardTitle.textContent = data.name;
        cardText.textContent = data.text;
        
        if (data.isSun) {
          cardTitle.style.color = '#ffa500';
        } else {
          cardTitle.style.color = `#${new THREE.Color(data.color).getHexString()}`;
        }

        if (!data.opened && !data.isSun) {
          data.opened = true;
          openedCount++;

          if (openedCount === planetData.length) {
            setTimeout(() => {
              finalUnlock.classList.add('show');
              sunGlow.material.uniforms.intensity.value *= 1.5;
              setTimeout(() => {
                finalUnlock.classList.remove('show');
                // Start meteor shower finale
                setTimeout(() => startMeteorShower(), 1000);
              }, 3000);
            }, 1000);
          }
        }

        card.classList.add("active");
      }
    }, { passive: false });

    closeBtn.addEventListener("mouseenter", () => cursor.classList.add("hovering"));
    closeBtn.addEventListener("mouseleave", () => cursor.classList.remove("hovering"));

    closeBtn.addEventListener("click", () => {
      focusedPlanet = null;
      card.classList.remove("active");
    });
    
    closeBtn.addEventListener("touchstart", (event) => {
      event.preventDefault();
      focusedPlanet = null;
      card.classList.remove("active");
    }, { passive: false });

    canvas.addEventListener("mousemove", (event) => {
      if (card.classList.contains("active")) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      
      const allClickables = [sun, ...planets];
      const intersects = raycaster.intersectObjects(allClickables, false);

      if (hoveredPlanet && (intersects.length === 0 || intersects[0].object !== hoveredPlanet)) {
        hoveredPlanet.userData.isHovered = false;
        hoveredPlanet = null;
      }

      if (intersects.length > 0) {
        hoveredPlanet = intersects[0].object;
        hoveredPlanet.userData.isHovered = true;
        cursor.classList.add("hovering");
        document.body.style.cursor = 'pointer';
      } else {
        cursor.classList.remove("hovering");
        document.body.style.cursor = 'none';
      }
    });

    // ANIMATION LOOP
    let time = 0;

    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;

      if (controls && controls.update) {
        controls.update();
      }

      // Update star twinkling
      if (starfield.userData.material) {
        starfield.userData.material.uniforms.time.value = time;
      }

      sun.rotation.y += 0.001;
      
      const basePulse = Math.sin(time * 0.5) * 0.05;
      sunGlow.material.uniforms.intensity.value = 0.8 + basePulse;
      
      if (sun.userData.isHovered) {
        const targetIntensity = 1.2;
        sunGlow.material.uniforms.intensity.value += (targetIntensity - sunGlow.material.uniforms.intensity.value) * 0.1;
      }

      starfield.rotation.y += 0.00005;
      starfield.rotation.x += 0.00002;
      
      milkyWay.rotation.z += 0.00015;
      
      nebulaClouds.rotation.y -= 0.0001;
      nebulaClouds.rotation.z += 0.00008;

      planets.forEach((planet, index) => {
        const data = planet.userData;

        data.angle += data.speed * 0.001;
        planet.position.x = Math.cos(data.angle) * data.distance;
        planet.position.z = Math.sin(data.angle) * data.distance;
        planet.position.y = data.baseY + Math.sin(time * 0.5 + index) * 0.5;

        planet.rotation.y += 0.005;
        
        if (data.clouds) {
          data.clouds.rotation.y += 0.007;
        }

        const isActive = planet === focusedPlanet || data.isHovered;
        const targetScale = isActive ? 1.5 : 1;
        
        planet.scale.lerp(
          new THREE.Vector3(targetScale, targetScale, targetScale),
          0.1
        );

        const targetIntensity = planet === focusedPlanet ? 1.5 : (data.isHovered ? 1.0 : 0.4);
        planet.material.emissiveIntensity += (targetIntensity - planet.material.emissiveIntensity) * 0.1;

        if (data.atmosphere) {
          const targetAtmosphereOpacity = data.isHovered ? 0.5 : 0.2;
          data.atmosphere.material.opacity += (targetAtmosphereOpacity - data.atmosphere.material.opacity) * 0.1;
        }

        if (data.ring) {
          const targetRingOpacity = data.isHovered ? 0.4 : 0;
          data.ring.material.opacity += (targetRingOpacity - data.ring.material.opacity) * 0.1;
        }
      });

      renderer.render(scene, camera);
    }

    animate();

    // KEYBOARD CONTROLS
    document.addEventListener('keydown', (e) => {
      const moveSpeed = 2;
      switch(e.key.toLowerCase()) {
        case 'w':
          camera.position.z -= moveSpeed;
          break;
        case 's':
          camera.position.z += moveSpeed;
          break;
        case 'a':
          camera.position.x -= moveSpeed;
          break;
        case 'd':
          camera.position.x += moveSpeed;
          break;
        case 'q':
          camera.position.y += moveSpeed;
          break;
        case 'e':
          camera.position.y -= moveSpeed;
          break;
        case 'r':
          camera.position.set(0, 15, 45);
          if (controls && controls.target) {
            controls.target.set(0, 0, 0);
            controls.update();
          }
          break;
        case ' ':
          e.preventDefault();
          if (controls && controls.autoRotate !== undefined) {
            controls.autoRotate = !controls.autoRotate;
          }
          break;
      }
    });

    // Reset view button
    const resetButton = document.createElement('button');
    resetButton.innerHTML = 'ðŸ”„ Reset View';
    resetButton.style.cssText = `
      position: fixed;
      bottom: 30px;
      right: 30px;
      padding: 12px 24px;
      background: rgba(10, 5, 30, 0.7);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 215, 0, 0.3);
      border-radius: 25px;
      color: #ffd700;
      font-size: 0.95rem;
      font-family: 'Crimson Text', serif;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 10;
    `;
    resetButton.onmouseover = () => {
      resetButton.style.background = 'rgba(255, 215, 0, 0.15)';
      resetButton.style.borderColor = 'rgba(255, 215, 0, 0.6)';
      resetButton.style.transform = 'scale(1.05)';
      cursor.classList.add('hovering');
    };
    resetButton.onmouseleave = () => {
      resetButton.style.background = 'rgba(10, 5, 30, 0.7)';
      resetButton.style.borderColor = 'rgba(255, 215, 0, 0.3)';
      resetButton.style.transform = 'scale(1)';
      cursor.classList.remove('hovering');
    };
    resetButton.onclick = () => {
      camera.position.set(0, 15, 45);
      if (controls && controls.target) {
        controls.target.set(0, 0, 0);
        controls.update();
      }
    };
    document.getElementById('spacePage').appendChild(resetButton);

    // RESIZE
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    }
  </script>
</body>
</html>